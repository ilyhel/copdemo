import { createBackedModelProxyHandler, DateOnly, Duration, parseGuidString, TimeOnly, isBackingStoreEnabled, toFirstCharacterUpper, isUntypedNode, createUntypedNodeFromDiscriminatorValue, createUntypedBoolean, createUntypedString, createUntypedNumber, createUntypedArray, createUntypedObject, createUntypedNull, } from "@microsoft/kiota-abstractions";
export class JsonParseNode {
    /**
     *
     */
    constructor(_jsonNode) {
        this._jsonNode = _jsonNode;
        this.getStringValue = () => this._jsonNode;
        this.getChildNode = (identifier) => this._jsonNode &&
            typeof this._jsonNode === "object" &&
            this._jsonNode[identifier] !== undefined
            ? new JsonParseNode(this._jsonNode[identifier])
            : undefined;
        this.getBooleanValue = () => this._jsonNode;
        this.getNumberValue = () => this._jsonNode;
        this.getGuidValue = () => parseGuidString(this.getStringValue());
        this.getDateValue = () => this._jsonNode ? new Date(this._jsonNode) : undefined;
        this.getDateOnlyValue = () => DateOnly.parse(this.getStringValue());
        this.getTimeOnlyValue = () => TimeOnly.parse(this.getStringValue());
        this.getDurationValue = () => Duration.parse(this.getStringValue());
        this.getCollectionOfPrimitiveValues = () => {
            return this._jsonNode.map((x) => {
                const currentParseNode = new JsonParseNode(x);
                const typeOfX = typeof x;
                if (typeOfX === "boolean") {
                    return currentParseNode.getBooleanValue();
                }
                else if (typeOfX === "string") {
                    return currentParseNode.getStringValue();
                }
                else if (typeOfX === "number") {
                    return currentParseNode.getNumberValue();
                }
                else if (x instanceof Date) {
                    return currentParseNode.getDateValue();
                }
                else if (x instanceof DateOnly) {
                    return currentParseNode.getDateValue();
                }
                else if (x instanceof TimeOnly) {
                    return currentParseNode.getDateValue();
                }
                else if (x instanceof Duration) {
                    return currentParseNode.getDateValue();
                }
                else {
                    throw new Error(`encountered an unknown type during deserialization ${typeof x}`);
                }
            });
        };
        this.getCollectionOfObjectValues = (method) => {
            return this._jsonNode ? this._jsonNode
                .map((x) => new JsonParseNode(x))
                .map((x) => x.getObjectValue(method)) : undefined;
        };
        this.getObjectValue = (parsableFactory) => {
            const temp = {};
            if (isUntypedNode(parsableFactory(this)(temp))) {
                const valueType = typeof this._jsonNode;
                let value = temp;
                if (valueType === "boolean") {
                    value = createUntypedBoolean(this._jsonNode);
                }
                else if (valueType === "string") {
                    value = createUntypedString(this._jsonNode);
                }
                else if (valueType === "number") {
                    value = createUntypedNumber(this._jsonNode);
                }
                else if (Array.isArray(this._jsonNode)) {
                    const nodes = [];
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    this._jsonNode.forEach((x) => {
                        nodes.push(new JsonParseNode(x).getObjectValue(createUntypedNodeFromDiscriminatorValue));
                    });
                    value = createUntypedArray(nodes);
                }
                else if (this._jsonNode && valueType === "object") {
                    const properties = {};
                    Object.entries(this._jsonNode).forEach(([k, v]) => {
                        properties[k] = new JsonParseNode(v).getObjectValue(createUntypedNodeFromDiscriminatorValue);
                    });
                    value = createUntypedObject(properties);
                }
                else if (!this._jsonNode) {
                    value = createUntypedNull();
                }
                return value;
            }
            const enableBackingStore = isBackingStoreEnabled(parsableFactory(this)(temp));
            const value = enableBackingStore ? new Proxy(temp, createBackedModelProxyHandler()) : temp;
            if (this.onBeforeAssignFieldValues) {
                this.onBeforeAssignFieldValues(value);
            }
            this.assignFieldValues(value, parsableFactory);
            if (this.onAfterAssignFieldValues) {
                this.onAfterAssignFieldValues(value);
            }
            return value;
        };
        this.assignFieldValues = (model, parsableFactory) => {
            const fields = parsableFactory(this)(model);
            if (!this._jsonNode)
                return;
            Object.entries(this._jsonNode).forEach(([k, v]) => {
                const deserializer = fields[k];
                if (deserializer) {
                    deserializer(new JsonParseNode(v));
                }
                else {
                    // additional properties
                    model[k] = v;
                }
            });
        };
        this.getCollectionOfEnumValues = (type) => {
            if (Array.isArray(this._jsonNode)) {
                return this._jsonNode
                    .map((x) => {
                    const node = new JsonParseNode(x);
                    return node.getEnumValue(type);
                })
                    .filter(Boolean);
            }
            return [];
        };
        this.getEnumValue = (type) => {
            const rawValue = this.getStringValue();
            if (!rawValue) {
                return undefined;
            }
            return type[toFirstCharacterUpper(rawValue)];
        };
    }
    getByteArrayValue() {
        const strValue = this.getStringValue();
        if (strValue && strValue.length > 0) {
            return Buffer.from(strValue, "base64").buffer;
        }
        return undefined;
    }
}
